## Design notes - June 13, 2025

Most of the UI and backend modules are missing. Need to add them back.

We should define a "moduleType" enum so that we can go from ModuleDef to backend classes.

We may be able to generate and update these definitions automatically (look into DsPy?)
Need a set of rules/heuristics to determine moduleType. We can also add integration tests
to see if our moduledefs have the same behavior as the corresponding pytorch modules.

More fields may be needed for certain moduleTypes to describe shape matching / inference
behaviors better. It may be good to keep a "standard library" of moduledefs somewhere: how
would they be implemented using this program? Makes the "multi-level" side stronger

Only compile down to linear algebra operations. It should be possible to fuse operations
at this level

Support for reading existing models: need to both parse python AST and use a tracer like
torch.fx or other stuff. Piece together the information to achieve some form of decompilation
and rebuild the model in our format. There are only so many different modules and the whole
thing needs to be differentiable so we should be able to do this. Worst case we don't decompile
and just "port" the thing at linear algebra level (can do that because of multiple layers)
